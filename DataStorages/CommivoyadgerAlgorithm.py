import numpy as np
import random

# ??????? ??? ????????? ????????? ??????? ??????????
def generate_distance_matrix(n):
    matrix = np.random.randint(1, 100, size=(n, n))
    matrix = (matrix + matrix.T) // 2
    np.fill_diagonal(matrix, 0)
    return matrix

# ??????? ????????????????? (???????? ???????? ?????? ??????????)
def fitness(route, distance_matrix):
    total_distance = sum([distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)])
    return 1 / total_distance

# ????????????? ?????????
def init_population(pop_size, n_cities):
    return [random.sample(range(n_cities), n_cities) for _ in range(pop_size)]

# ???????????
def crossover(parent1, parent2):
    # ?????????? ???????????? ??????????? ??? ??????
    point = random.randint(1, len(parent1) - 2)
    child1 = parent1[:point] + [city for city in parent2 if city not in parent1[:point]]
    child2 = parent2[:point] + [city for city in parent1 if city not in parent2[:point]]
    return child1, child2

# ???????
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# ??????? ??????? ????????????? ?????????
def genetic_algorithm(n_cities, pop_size, n_generations, mutation_rate):
    distance_matrix = generate_distance_matrix(n_cities)
    population = init_population(pop_size, n_cities)
    
    for _ in range(n_generations):
        # ?????? ?????????????????
        fitness_scores = [fitness(route, distance_matrix) for route in population]
        
        # ????? ??? ??????????? (????? ???????????? ?????? ??????)
        selected_indices = np.random.choice(range(pop_size), size=pop_size, replace=True, p=[f/sum(fitness_scores) for f in fitness_scores])
        selected = [population[i] for i in selected_indices]
        
        # ??????????? ? ???????
        next_population = []
        for i in range(0, pop_size, 2):
            child1, child2 = crossover(selected[i], selected[i+1])
            next_population.append(mutate(child1, mutation_rate))
            next_population.append(mutate(child2, mutation_rate))
        
        population = next_population
    
    # ?????????? ?????? ???????
    best_route_index = np.argmax([fitness(route, distance_matrix) for route in population])
    return population[best_route_index], 1 / fitness(population[best_route_index], distance_matrix)

# ????????? ?????????
n_cities = 10  # ?????????? ???????
pop_size = 100  # ?????? ?????????
n_generations = 1000  # ?????????? ?????????
mutation_rate = 0.01  # ??????????? ???????

# ?????? ?????????
best_route, best_distance = genetic_algorithm(n_cities, pop_size, n_generations, mutation_rate)
print(f"?????? ???????: {best_route}\n????? ??????????: {best_distance}")

